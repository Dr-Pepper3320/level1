<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Troll Chief Duel</title>
  <style>
    :root{
      --bg:#070a10;
      --fg:#d7ffe3;
      --muted:#9bd7b0;
      --accent:#6df;
      --danger:#ff6b6b;
      --ok:#6bff95;
      --panel:rgba(8,12,18,.80);
      --panel2:rgba(8,12,18,.92);
      --border:rgba(255,255,255,.12);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{width:100%;height:100%;background:var(--bg);color:var(--fg);overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    #wrap{position:relative;width:100%;height:100%}
    canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering:pixelated}

    .hud{
      position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:8px;
      padding:10px 12px;background:var(--panel);border:1px solid var(--border);border-radius:10px;
      min-width:270px;backdrop-filter:blur(6px)
    }
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .label{font-size:12px;color:var(--muted)}
    .bar{height:10px;background:rgba(255,255,255,.10);border:1px solid var(--border);border-radius:999px;overflow:hidden;flex:1}
    .fill{height:100%;width:100%}
    .tiny{font-size:12px;color:rgba(255,255,255,.72);line-height:1.25}
    .hint{font-size:12px;color:rgba(255,255,255,.74)}
    .centerPanel{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      padding:14px 16px;min-width:min(520px,92vw);
      background:var(--panel2);border:1px solid var(--border);border-radius:14px;
      box-shadow:0 18px 55px rgba(0,0,0,.55);display:none
    }
    .centerPanel h2{font-size:18px;margin-bottom:8px}
    .centerPanel p{font-size:13px;color:rgba(255,255,255,.78);margin-bottom:12px}
    .btnRow{display:flex;gap:10px;justify-content:flex-end}
    button{
      appearance:none;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--fg);
      padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:700
    }
    button.primary{background:rgba(109,255,149,.14);border-color:rgba(109,255,149,.40)}
    button.danger{background:rgba(255,107,107,.12);border-color:rgba(255,107,107,.35)}
    #msg{
      position:absolute;left:50%;bottom:14px;transform:translateX(-50%);
      padding:10px 12px;background:var(--panel);border:1px solid var(--border);border-radius:12px;
      font-size:13px;color:rgba(255,255,255,.84);display:none
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="row"><div class="label">You</div><div class="bar"><div id="pFill" class="fill" style="background:var(--ok)"></div></div><div id="pTxt" class="tiny">100 / 100</div></div>
    <div class="row"><div class="label">Troll Chief</div><div class="bar"><div id="bFill" class="fill" style="background:var(--danger)"></div></div><div id="bTxt" class="tiny">180 / 180</div></div>
    <div class="hint">Move: WASD / Arrows • Attack: Click or Space • Fire: Q • Shock: E</div>
  </div>

  <div id="panel" class="centerPanel">
    <h2 id="panelTitle">Duel</h2>
    <p id="panelBody">...</p>
    <div class="btnRow">
      <button id="btnReturn" class="danger">Return</button>
      <button id="btnRetry" class="primary">Retry</button>
    </div>
  </div>

  <div id="msg"></div>
</div>

<!-- Pull the same combat sprite system Level 1 uses -->
<script src="systems_merged.js"></script>

<script>
(() => {
  // ---------- URL / return bridge ----------

  function getActiveSlot(){
    try{ return localStorage.getItem("np_active_save_slot") || "slot1"; }catch(_){ return "slot1"; }
  }
  function dlgKey(id){
    // Must match dialogue_merged_slot_enabled.js
    return "dlg_scripted_state_v2__" + getActiveSlot() + "__" + id;
  }

  const qs = new URLSearchParams(location.search);
  const encounterId = qs.get("encounter") || "encounter.troll_duel_grath";

  let returnUrl = qs.get("return");
  if(!returnUrl){
    try{ returnUrl = localStorage.getItem("np_duel_return_url_v1"); }catch(_){}
  }
  if(!returnUrl){
    // Slot-enabled build entry (launcher uses this)
    returnUrl = "level1_slot_enabled_v2.html";
  }

  try{ localStorage.setItem("np_duel_return_url_v1", String(returnUrl)); }catch(_){}

  function goBack(){
    // ensure we always go back to the exact Level 1 URL the user came from
    location.href = String(returnUrl);
  }

  function setPayload(obj){
    try{ localStorage.setItem("np_return_payload_v1", JSON.stringify(obj)); }catch(_){}
  }

  // ---------- Canvas + helpers ----------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  function resize(){
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio||1));
    canvas.width = Math.floor(innerWidth*dpr);
    canvas.height = Math.floor(innerHeight*dpr);
    canvas.style.width = innerWidth+"px";
    canvas.style.height = innerHeight+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  // ---------- Minimal state used by Combat ----------
  const CFG = {
    player: { radius: 10 },
    combat: {
      // tuned for 1v1 arena
      meleeRange: 40,
      fireballSpeed: 520,
      fireballDamage: 18,
      shockDamage: 10,
      shockRange: 150
    }
  };

  const state = {
    t: 0,
    dt: 0,
    world: { w: innerWidth, h: innerHeight },
    player: {
      x: innerWidth*0.28,
      y: innerHeight*0.56,
      hp: 100,
      maxHp: 100,
      faceX: 1,
      faceY: 0
    }
  };

  // Expose for debugging if needed
  window.__DUEL_STATE__ = state;

  // Mouse object Combat expects (wx/wy are "world" coordinates)
  const mouse = { wx: state.player.x, wy: state.player.y };
  function setMouseFromEvent(e){
    const r = canvas.getBoundingClientRect();
    mouse.wx = (e.clientX - r.left);
    mouse.wy = (e.clientY - r.top);
  }
  canvas.addEventListener("mousemove", (e)=>{ setMouseFromEvent(e); }, {passive:true});
  canvas.addEventListener("mousedown", (e)=>{
    setMouseFromEvent(e);
    if(window.Combat && typeof Combat.onMouseDown === "function"){
      Combat.onMouseDown(e);
    }
  });

  // ---------- Troll Chief sprite (same as Level 1) ----------
  const TROLLCHIEF = {
    ready:false,
    size:64,
    idle:{ count:4, fps:6, frames:{}, },
    talk:{ count:4, fps:10, frames:{}, },
    cache:{ idle:{}, talk:{} },
    _cacheBuilt:false
  };

  (function preloadTrollChief(){
    let pending = 0, loaded = 0;
    const onDone = () => { loaded++; if(loaded >= pending){ TROLLCHIEF.ready = true; } };

    const loadSet = (store, base, count) => {
      for(let i=1;i<=count;i++){
        pending++;
        const img = new Image();
        img.src = base + i + ".png";
        img.onload = onDone;
        img.onerror = ()=>{ onDone(); try{ console.warn("[TROLLCHIEF] Missing sprite:", img.src); }catch(_){} };
        store[i] = img;
      }
    };

    loadSet(TROLLCHIEF.idle.frames, "assets/npc/trollchief/idle/", TROLLCHIEF.idle.count);
    loadSet(TROLLCHIEF.talk.frames, "assets/npc/trollchief/talking/", TROLLCHIEF.talk.count);
  })();

  function buildTrollChiefCache(){
    if(TROLLCHIEF._cacheBuilt || !TROLLCHIEF.ready) return;
    const makeScaled = (img) => {
      const c = document.createElement("canvas");
      c.width = TROLLCHIEF.size;
      c.height = TROLLCHIEF.size;
      const cctx = c.getContext("2d");
      cctx.imageSmoothingEnabled = false;
      cctx.clearRect(0,0,c.width,c.height);
      try{ cctx.drawImage(img, 0, 0, c.width, c.height); }catch(_){}
      return c;
    };
    for(const k of ["idle","talk"]){
      const src = (k==="idle") ? TROLLCHIEF.idle.frames : TROLLCHIEF.talk.frames;
      const dst = (k==="idle") ? TROLLCHIEF.cache.idle : TROLLCHIEF.cache.talk;
      for(let i=1;i<=4;i++){
        const img = src[i];
        if(img && img.complete && img.naturalWidth>0){
          dst[i] = makeScaled(img);
        }
      }
    }
    TROLLCHIEF._cacheBuilt = true;
  }

  function drawTrollChief(enemy){
    // shadow
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(enemy.x, enemy.y + 24, 18, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    const size = TROLLCHIEF.size;
    const dx = Math.floor(enemy.x - size/2);
    const dy = Math.floor(enemy.y - size/2) - 10;

    let img = null;
    if(TROLLCHIEF.ready){
      buildTrollChiefCache();
      const talking = (enemy.attackWind > 0.05); // "snarl" during attack windup
      if(talking){
        const idx = 1 + (Math.floor(state.t * TROLLCHIEF.talk.fps) % TROLLCHIEF.talk.count);
        img = TROLLCHIEF.cache.talk[idx] || TROLLCHIEF.talk.frames[idx];
      }else{
        const idx = 1 + (Math.floor(state.t * TROLLCHIEF.idle.fps) % TROLLCHIEF.idle.count);
        img = TROLLCHIEF.cache.idle[idx] || TROLLCHIEF.idle.frames[idx];
      }
    }

    if(img){
      ctx.save();
      ctx.imageSmoothingEnabled = false;
      try{ ctx.drawImage(img, dx, dy); }catch(_){}
      ctx.restore();
    }else{
      // fallback silhouette
      ctx.save();
      ctx.fillStyle = "#2b3a33";
      ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.r, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // ---------- Minimal EnemySystem for Combat integration ----------
  const boss = {
    id: "trollchief",
    type: "trollchief",
    x: innerWidth*0.72,
    y: innerHeight*0.56,
    r: 18,
    hitR: 22,
    hp: 180,
    maxHp: 180,
    dead: false,
    hurtT: 0,
    attackCD: 0,
    attackWind: 0,
    attackRange: 40,
    speed: 115
  };

  const EnemySystem = {
    getEnemies: ()=> boss.dead ? [] : [boss],
    getHitRadius: (e)=> (e && e.hitR) ? e.hitR : (e && e.r) ? e.r : 12,
    damageEnemy: (e, dmg, src)=>{
      if(!e || e.dead) return false;
      const d = Math.max(1, Number(dmg)||1);
      e.hp = Math.max(0, e.hp - d);
      e.hurtT = 0.18;
      if(e.hp <= 0){
        e.dead = true;
      }
      // tiny knockback from player
      if(src && src.x!=null){
        const dx = e.x - src.x, dy = e.y - src.y;
        const L = Math.hypot(dx,dy) || 1;
        e.x += (dx/L) * 6;
        e.y += (dy/L) * 6;
      }
      return true;
    }
  };

  // Attach for Combat module
  window.EnemySystem = EnemySystem;

  // A tiny toast used by Combat (optional)
  window.toast = (msg)=> showMsg(String(msg||""));

  // ---------- Init Combat (from systems_merged.js) ----------
  if(window.Combat && typeof Combat.init === "function"){
    Combat.init({
      CFG,
      state,
      clamp,
      toast: window.toast
    });
    Combat.setMouse(mouse);
  }

  // ---------- Player movement ----------
  const keys = new Set();
  addEventListener("keydown", (e)=>{
    keys.add(e.key.toLowerCase());
    if(window.Combat && typeof Combat.onKeyDown === "function"){
      Combat.onKeyDown(e);
    }
  });
  addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

  function stepPlayer(dt){
    const p = state.player;
    let vx = 0, vy = 0;
    if(keys.has("w") || keys.has("arrowup")) vy -= 1;
    if(keys.has("s") || keys.has("arrowdown")) vy += 1;
    if(keys.has("a") || keys.has("arrowleft")) vx -= 1;
    if(keys.has("d") || keys.has("arrowright")) vx += 1;

    const mag = Math.hypot(vx,vy);
    if(mag > 0){
      vx /= mag; vy /= mag;
      const sp = 210;
      p.x = clamp(p.x + vx*sp*dt, 26, innerWidth-26);
      p.y = clamp(p.y + vy*sp*dt, 26, innerHeight-26);
      p.faceX = vx; p.faceY = vy;
    }else{
      // face toward mouse if standing
      const dx = mouse.wx - p.x, dy = mouse.wy - p.y;
      const L = Math.hypot(dx,dy);
      if(L > 0.001){
        p.faceX = dx / L;
        p.faceY = dy / L;
      }
    }
  }

  // ---------- Boss AI ----------
  function bossAttack(dt){
    if(boss.dead) return;
    const p = state.player;

    boss.hurtT = Math.max(0, boss.hurtT - dt);
    boss.attackCD = Math.max(0, boss.attackCD - dt);
    boss.attackWind = Math.max(0, boss.attackWind - dt);

    // move toward player
    const dx = p.x - boss.x, dy = p.y - boss.y;
    const L = Math.hypot(dx,dy) || 1;
    const distTo = L;

    // keep a little spacing so melee is readable
    const desired = boss.attackRange - 6;

    if(distTo > desired){
      const sp = boss.speed * (boss.hurtT>0 ? 0.65 : 1.0);
      boss.x = clamp(boss.x + (dx/L)*sp*dt, 30, innerWidth-30);
      boss.y = clamp(boss.y + (dy/L)*sp*dt, 30, innerHeight-30);
    }

    // attack
    if(distTo < boss.attackRange && boss.attackCD <= 0){
      boss.attackWind = 0.22;
      boss.attackCD = 1.05;
    }

    // deal damage at the end of the windup
    if(boss.attackWind > 0 && boss.attackWind - dt <= 0.001){
      // re-check range at hit moment
      if(dist(boss.x,boss.y, p.x,p.y) < boss.attackRange + 6){
        const dmg = 18;
        p.hp = Math.max(0, p.hp - dmg);
        showMsg("The Troll Chief strikes you for "+dmg+"!");
      }
    }
  }

  // ---------- UI ----------
  const pFill = document.getElementById("pFill");
  const bFill = document.getElementById("bFill");
  const pTxt  = document.getElementById("pTxt");
  const bTxt  = document.getElementById("bTxt");
  const panel = document.getElementById("panel");
  const panelTitle = document.getElementById("panelTitle");
  const panelBody = document.getElementById("panelBody");
  const btnRetry = document.getElementById("btnRetry");
  const btnReturn = document.getElementById("btnReturn");
  const msg = document.getElementById("msg");

  let msgT = 0;
  function showMsg(s){
    msg.textContent = s;
    msg.style.display = "block";
    msgT = 2.2;
  }

  function showPanel(title, body, win){
    panelTitle.textContent = title;
    panelBody.textContent = body;
    panel.style.display = "block";
    btnRetry.style.display = win ? "none" : "inline-block";
    btnReturn.textContent = win ? "Continue" : "Return";
  }

  btnReturn.onclick = ()=> goBack();
  btnRetry.onclick = ()=> location.reload();

  // ---------- Game loop ----------
  let last = performance.now();

  function draw(){
    ctx.clearRect(0,0,innerWidth,innerHeight);

    // arena background
    ctx.save();
    ctx.fillStyle = "#0b111a";
    ctx.fillRect(0,0,innerWidth,innerHeight);
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "#6df";
    ctx.lineWidth = 2;
    ctx.strokeRect(24,24,innerWidth-48,innerHeight-48);
    ctx.restore();

    // Boss first (behind player a bit)
    if(!boss.dead) drawTrollChief(boss);

    // Player sprite via Combat module (uses the same PNG packs as Level 1)
    if(window.Combat && typeof Combat.drawPlayer === "function"){
      Combat.drawPlayer(ctx);
    }else{
      ctx.save();
      ctx.fillStyle = "#d7ffe3";
      ctx.beginPath(); ctx.arc(state.player.x, state.player.y, 10, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // Combat effects (fireballs / shockwaves)
    if(window.Combat && typeof Combat.draw === "function"){
      Combat.draw(ctx);
    }

    // hurt flash on boss
    if(!boss.dead && boss.hurtT > 0){
      ctx.save();
      ctx.globalAlpha = 0.35 * (boss.hurtT / 0.18);
      ctx.fillStyle = "#ff6b6b";
      ctx.beginPath(); ctx.arc(boss.x, boss.y, boss.r+10, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  function updateUI(){
    const p = state.player;
    pFill.style.width = (100 * (p.hp / p.maxHp)) + "%";
    bFill.style.width = (100 * (boss.hp / boss.maxHp)) + "%";
    pTxt.textContent = Math.ceil(p.hp) + " / " + p.maxHp;
    bTxt.textContent = Math.ceil(boss.hp) + " / " + boss.maxHp;
  }

  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    state.t += dt;
    state.dt = dt;

    // keep world synced to current size
    state.world.w = innerWidth;
    state.world.h = innerHeight;

    if(panel.style.display !== "block"){
      stepPlayer(dt);
      bossAttack(dt);

      if(window.Combat && typeof Combat.update === "function"){
        Combat.update(dt);
      }

      if(msgT > 0){
        msgT = Math.max(0, msgT - dt);
        if(msgT <= 0) msg.style.display = "none";
      }

      // Win / lose
      if(!boss.dead && boss.hp <= 0){
        boss.dead = true;
      }

      if(boss.dead){
        // mark duel complete for the trollchief conversation
        try{
          const raw = localStorage.getItem(dlgKey("trollchief"));
          const st = raw ? JSON.parse(raw) : {};
          st.flags = st.flags || {};
          st.flags.duel_won = true;
          localStorage.setItem(dlgKey("trollchief"), JSON.stringify(st));
        }catch(_){}

        setPayload({ type:"encounter_cleared", encounterId, won:true, ts:Date.now() });
        showPanel("Victory", "The Troll Chief bows. Your name will be spoken with respect.", true);
      }else if(state.player.hp <= 0){
        setPayload({ type:"encounter_failed", encounterId, won:false, ts:Date.now() });
        showPanel("Defeat", "You fall. The Troll Chief spares you this time—return when you are ready.", false);
      }

      updateUI();
      draw();
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
